\documentclass[10pt,a4paper]{article}
\linespread{1.1}
% layout/typography
\usepackage[hmargin=2.75cm,vmargin=3cm]{geometry}
\usepackage[english]{babel} % use Dutch hyphenation etc.
\usepackage{parskip}         % don't indent paragraphs and leave vertical space instead
\usepackage[T1]{fontenc}  % make accented work properly in pdf
\renewcommand{\thefootnote}{\fnsymbol{footnote}} % use symbols for footnotes

% math stuff
\usepackage{amssymb,amsmath,amsthm,dsfont,hyperref}

% set up alternative commands to allow for easy adaptation to the notation of the textbook.
\newcommand{\sub}{\subset}           % new command to refer to standard notation \subset for standard subset (which might be equal)
\newcommand{\subneq}{\subsetneq} % new command to refer to standard notation \subsetneq for proper subset (not allowed to be equal)
% Uncomment the lines below to use the notation of the textbook
%    Comment the lines below to use more common notations (for (proper) subsets, negation and set difference)
\renewcommand{\sub}{\subseteq}      % use \subseteq instead of \subset for standard subset (which might be equal)
%\renewcommand{\subneq}{\subset} % use \subset instead of \subsetneq for proper subset (which is not allowed to be equal)
%\renewcommand{\setminus}{-}        % use - instead of \ for relative complement of sets
%\renewcommand{\neg}{{\sim}}       % use ~ as negation symbol

% misc.
\usepackage{enumitem} % for the [resume] option
\renewcommand{\theenumi}{\alph{enumi}}
\renewcommand{\theenumii}{\roman{enumii}}

\usepackage{graphicx,caption}
\usepackage{threeparttable}
\captionsetup{labelfont = sc, textfont = it}

\makeatletter
\renewcommand*\env@matrix[1][*\c@MaxMatrixCols c]{%
	\hskip -\arraycolsep
	\let\@ifnextchar\new@ifnextchar
	\array{#1}}

\newcommand{\norm}[1]{\lvert\lvert #1 \rvert\rvert}

\usepackage{tikz,xcolor}
\usepackage{ upgreek }


\def\point[#1]{
	\draw (#1) node[fill=black,thick,circle,minimum size=2.2pt,inner sep=0pt,outer sep=0pt] {};
	\draw (#1) node[fill=white,semithick,circle,minimum size=1pt,inner sep=0pt,outer sep=0pt] {};
}

\newcommand{\R}{\mathbb{R}}
\newcommand{\x}{\textbf{x}}
\newcommand{\y}{\textbf{y}}
\newcommand{\0}{\textbf{0}}
\renewcommand{\l}{\langle}
\renewcommand{\r}{\rangle}
\renewcommand{\v}{\textbf{v}}
\newcommand{\z}{\textbf{z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\Z}{\mathbb{Z}}
\renewcommand{\P}{\mathbb{P}}
\renewcommand{\O}{\mathcal{O}}
\newcommand{\F}{\mathcal{F}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\A}{\mathbb{A}}
\renewcommand{\a}{\alpha}
\renewcommand{\b}{\beta}
\newcommand{\e}{\varepsilon}
\newcommand{\p}{\varphi}
\renewcommand{\d}[2]{\frac{d#1}{d#2}}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}



\def\subto{\mathrel{\vcenter{\hbox{\scalebox{.6}{$\supset$}}}\kern-.4em\to}}
\usepackage{lmodern} 

\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.7, 0.1, 0.1}   % red
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}      % green
\definecolor{errorcolor}{rgb}{1, 0, 0}           % bright red
\definecolor{stringcolor}{rgb}{0.5, 0.3, 0.2}    % brown

\usepackage{listings}
\def\lstlanguagefiles{lstlean.tex}
\lstset{language=lean}


\begin{document}
	\section*{\vspace{-1.5cm}\begin{center}\normalsize\normalfont{Homework 6, Formal Methods in Mathematics\\University Utrecht, \today\\AKS primality group\\Lena van Dongen, Roxy van de Kuilen, Tamira Lopes, Fran\c{c}ois van der Rhee}\end{center}}
	\vspace{-\baselineskip}\noindent \rule{\textwidth}{0.025cm}\vspace{\parskip}
	\section*{Project description}
	For the final project, we would like to explore the AKS primality test in Lean. This means that we will be occupied with the number theory associated to this problem. 
	In a later version of the original proof, we see that this entails inequalities, as well as modulo calculations and cyclic groups. In the final parts of the proof, we will need to use cyclotomic polynomials.
	Furthermore, we will need to prove some results about the cardinality of some group generated by $X$, $X+1$, ..., $X+l$ in the field $F_p[X]/(h(X))$. 
	If we have enough time left, we also want to look into proving the time complexity of this algorithm.
	
	\section*{Project goals}
	We need to define the algorithm in Lean. We think the best way to implement it, is by defining a function that takes in an integer $n>1$ and gives an output `PRIME' or `COMPOSITE', following the algorithm.
	Our main goal is proving the statement \textit{The AKS primality algorithm returns `PRIME' if and only if $n$ is prime}.
	For this, we will use the definitions, lemmas and theorems as described in PRIMES is in P \cite{PRIMES in P}. This means that we need to implement the following, all found in \cite{PRIMES in P}:
	\begin{itemize}
		\item Lemma 2.1: Let $a\in\Z$, $n\in\N$, $n\geq2$ and $(a,n)=1$. Then $n$ is prime if and only if $(X+a)^n=X^n+a \ (\text{mod } n)$.
		\item Theorem 4.1: The AKS algorithm returns `PRIME' if and only if $n$ is prime.
		\item Lemma 4.2: If $n$ is prime, the AKS algorithm returns `PRIME'.
		\item Lemma 4.3: There exists an $r\leq \max\{3,\left\lceil \log^5n\right\rceil\}$ such that $o_r(n)>\log^2n$.
		\item Definition 4.4: For a polynomial $f(X)$ and number $m\in\N$, we say that $m$ is introspective for $f(X)$ if $f(X)^m=f(X^m)\ (\text{mod } X^r-1,p)$.
		\item Lemma 4.5: If $m$ and $m′$ are introspective numbers for $f (X)$ then so is $m \cdot m′$.
		\item Lemma 4.6: If $m$ is introspective for $f(X)$ and $g(X)$ then it is also introspective for $f (X) \cdot g(X)$.
		\item Lemma 4.7: $|\mathcal{G}| \ge {t+l \choose t-1} $.
		\item Lemma 4.8: If $n$ is not a power of $p$ then $|\mathcal{G}|\le n^{\sqrt t}$.
		\item Lemma 4.9: If the algorithm returns PRIME then $n$ is prime.
	\end{itemize}
	
	\section*{Division of labour}
	For the initial division of labour, we decided that we want to define the algorithm together, such that we all know how the most important part of our project is defined.
	Once that is done, we can easily formalize the theorem statement together, again to all have clear what we are working with.
	After that, we will divide the work such that everyone has a similar workload.
	
	
	\section*{First definitions and theorem statements in Lean}
	We have implemented the AKS algorithm described in the paper (\texttt{AKS\_algorithm}), and the definitions that this needs. We have also given the theorem and lemma statements of the main results we are aiming to prove.
	
	\begin{lstlisting}[
		frame=single,
		numbers=left]
	import Mathlib
		
	open Polynomial
	open Finset
		
	inductive AKS_Output where
	| PRIME : AKS_Output
	| COMPOSITE : AKS_Output
		
	export AKS_Output (PRIME COMPOSITE)
		
	def perfect_power (n : ℕ) : Prop :=
		∃ (a b : ℕ), b > 1 ∧ n = a ^ b
		
	instance {n : ℕ} : Decidable (perfect_power n) := by
		sorry
		
	noncomputable
	def o_r (r n : ℕ) (h : n.gcd r = 1): ℕ :=
	-- the order of n in (ℤ/rℤ)ˣ
		orderOf (ZMod.unitOfCoprime n h : (ZMod r)ˣ)
		
	noncomputable
	def o_r' (r n : ℕ) : ℕ :=
		if h : gcd n r = 1 then
			o_r r n h
		else
			0
		
	noncomputable
	def smallest_r (n : ℕ) : ℕ :=
		sInf {r : ℕ | o_r' r n > (Real.log n) ^ 2}
		
	def is_not_coprime_in_range (r n : ℕ) : Prop :=
		∃ a : ℕ, a ≤ r ∧ 1 < gcd a n ∧ gcd a n < n
		
	instance {r n : ℕ} : Decidable (is_not_coprime_in_range r n) := by
		sorry
		
	def polynomial_equality (r n a : ℕ) : Prop :=
		(((X + C (a : ℤ))^n : ℤ[X]) : ℤ[X] ⧸ Ideal.span ({X^r - 1, C (n : ℤ)} : Set ℤ[X])) = (X^n + C (a : ℤ) : ℤ[X])
		
	def step_5_false (r n : ℕ) : Prop :=
		∃ a : ℕ, 1 ≤ a ∧ a ≤ Nat.floor (Real.sqrt r.totient * Real.log n) ∧ ¬polynomial_equality r n a
		
	instance {r n : ℕ} : Decidable (step_5_false r n) := by
		sorry
		
	noncomputable
	def AKS_algorithm {n: ℕ} (ngt1 : 1 < n) : AKS_Output :=
		if perfect_power n ∨ is_not_coprime_in_range (smallest_r n) n ∨ (smallest_r n < n ∧ step_5_false (smallest_r n) n) then
			COMPOSITE
		else
			PRIME
		
	lemma lem3_1 (n : ℕ) (hn : 7 ≤ n) : 4 ^ n ≤ (erase (range n) 0).lcm id := by
		sorry
		
	lemma lemma_4_2 (n : ℕ) (ngt1 : 1 < n) : Nat.Prime n → AKS_algorithm ngt1 = PRIME := sorry
		
	lemma lemma_4_9 (n : ℕ) (ngt1 : 1 < n) : AKS_algorithm ngt1 = PRIME → Nat.Prime n := sorry
		
	theorem theorem_4_1 (n : ℕ) (ngt1 : 1 < n) : n.Prime ↔ AKS_algorithm ngt1 = PRIME := by
		constructor
		exact lemma_4_2 n ngt1
		exact lemma_4_9 n ngt1
	\end{lstlisting}
	
	
	
	\begin{thebibliography}{0}
		\bibitem{PRIMES in P}
		Agrawal, Manindra, Neeraj Kayal, and Nitin Saxena. "PRIMES is in P." Annals of mathematics (2004): 781-793.
	\end{thebibliography}
	
\end{document}
